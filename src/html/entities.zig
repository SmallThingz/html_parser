const std = @import("std");
const scanner = @import("scanner.zig");

const Decoded = struct {
    consumed: usize,
    bytes: [4]u8,
    len: usize,
};

pub fn decodeInPlace(slice: []u8) usize {
    return decodeInPlaceFrom(slice, 0);
}

pub fn decodeInPlaceIfEntity(slice: []u8) usize {
    // Fast reject to keep the no-entity path single-pass and branch-light.
    const first = scanner.findByte(slice, 0, '&') orelse return slice.len;
    return decodeInPlaceFrom(slice, first);
}

fn decodeInPlaceFrom(slice: []u8, start_index: usize) usize {
    var r: usize = start_index;
    var w: usize = start_index;

    while (r < slice.len) {
        const amp_rel = scanner.findByte(slice, r, '&') orelse {
            if (w != r) {
                std.mem.copyForwards(u8, slice[w .. w + (slice.len - r)], slice[r..slice.len]);
            }
            w += slice.len - r;
            break;
        };

        if (amp_rel > r) {
            const chunk_len = amp_rel - r;
            if (w != r) {
                std.mem.copyForwards(u8, slice[w .. w + chunk_len], slice[r..amp_rel]);
            }
            w += chunk_len;
            r = amp_rel;
        }

        const maybe = decodeEntity(slice[r..]);
        if (maybe) |decoded| {
            // Copy decoded scalar bytes directly into the write cursor.
            std.mem.copyForwards(u8, slice[w .. w + decoded.len], decoded.bytes[0..decoded.len]);
            r += decoded.consumed;
            w += decoded.len;
            continue;
        }

        slice[w] = slice[r];
        r += 1;
        w += 1;
    }

    return w;
}

fn decodeEntity(rem: []const u8) ?Decoded {
    if (rem.len < 4 or rem[0] != '&') return null;

    if (std.mem.startsWith(u8, rem[1..], "amp;")) return literalDecoded(5, '&');
    if (std.mem.startsWith(u8, rem[1..], "lt;")) return literalDecoded(4, '<');
    if (std.mem.startsWith(u8, rem[1..], "gt;")) return literalDecoded(4, '>');
    if (std.mem.startsWith(u8, rem[1..], "quot;")) return literalDecoded(6, '"');
    if (std.mem.startsWith(u8, rem[1..], "apos;")) return literalDecoded(6, '\'');

    if (rem.len >= 4 and rem[1] == '#') {
        if (parseNumeric(rem)) |n| {
            return .{ .consumed = n.consumed, .bytes = n.bytes, .len = n.len };
        }
    }

    return null;
}

fn literalDecoded(consumed: usize, c: u8) Decoded {
    return .{
        .consumed = consumed,
        .bytes = .{ c, 0, 0, 0 },
        .len = 1,
    };
}

fn parseNumeric(rem: []const u8) ?struct { consumed: usize, bytes: [4]u8, len: usize } {
    if (rem.len < 4 or rem[0] != '&' or rem[1] != '#') return null;

    var i: usize = 2;
    var base: u32 = 10;
    if (i < rem.len and (rem[i] == 'x' or rem[i] == 'X')) {
        base = 16;
        i += 1;
    }

    const start = i;
    var value: u32 = 0;
    while (i < rem.len and rem[i] != ';') : (i += 1) {
        const digit = decodeDigit(rem[i], base) orelse return null;
        const limit = (0x10FFFF - digit) / base;
        if (value > limit) return null;
        value = value * base + digit;
        if (value > 0x10FFFF) return null;
    }

    if (i == start or i >= rem.len or rem[i] != ';') return null;

    var out: [4]u8 = undefined;
    const codepoint: u21 = @intCast(value);
    const len = std.unicode.utf8Encode(codepoint, &out) catch return null;
    return .{ .consumed = i + 1, .bytes = out, .len = len };
}

fn decodeDigit(c: u8, base: u32) ?u32 {
    return switch (c) {
        '0'...'9' => c - '0',
        'a'...'f' => if (base == 16) 10 + (c - 'a') else null,
        'A'...'F' => if (base == 16) 10 + (c - 'A') else null,
        else => null,
    };
}

test "decode entities" {
    var buf = "a&amp;b&#x20;".*;
    const n = decodeInPlace(&buf);
    try std.testing.expectEqualStrings("a&b ", buf[0..n]);
}
